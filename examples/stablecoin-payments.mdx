---
title: 'Stablecoin Payments'
description: 'Accept USDC, USDT, and other stablecoins from any chain with automatic bridging.'
icon: 'dollar-sign'
---

## Overview

Stablecoins are the preferred settlement currency for crypto payments. Trails handles cross-chain bridging and swapping automatically—your users pay with any token, you receive stablecoins.

| Benefit | How Trails Helps |
|---------|-----------------|
| Price stability | Settle in USDC/USDT to avoid volatility |
| Cross-chain reach | Accept payments from 15+ chains |
| No user friction | Users pay with whatever they have |
| Native bridging | CCTP for native USDC transfers |

## USDC Cross-Chain Examples

### Accept USDC on Base (Lowest Fees)

Base offers the lowest transaction fees for USDC settlement:

```tsx
import { TrailsWidget } from '0xtrails/widget'

<TrailsWidget
  apiKey="YOUR_API_KEY"
  mode="pay"
  toAddress="0xYOUR_MERCHANT_ADDRESS"
  toAmount="50"
  toChainId={8453} // Base
  toToken="USDC"
  onCheckoutComplete={({ sessionId }) => {
    verifyPayment(sessionId)
  }}
>
  <button>Pay $50</button>
</TrailsWidget>
```

User pays with ETH on Arbitrum → Trails bridges and swaps → You receive USDC on Base.

### Accept USDC on Arbitrum

```tsx
<TrailsWidget
  apiKey="YOUR_API_KEY"
  mode="pay"
  toAddress="0xYOUR_MERCHANT_ADDRESS"
  toAmount="100"
  toChainId={42161} // Arbitrum
  toToken="USDC"
  onCheckoutComplete={({ sessionId }) => {
    confirmOrder(sessionId)
  }}
>
  <button>Pay $100 in USDC</button>
</TrailsWidget>
```

### Native USDC Bridging with CCTP

Circle's Cross-Chain Transfer Protocol (CCTP) enables native USDC transfers without wrapped tokens:

```tsx
<TrailsWidget
  apiKey="YOUR_API_KEY"
  mode="pay"
  toAddress="0xYOUR_MERCHANT_ADDRESS"
  toAmount="1000"
  toChainId={1} // Ethereum mainnet
  toToken="USDC"
  bridgeProvider="CCTP" // Native USDC bridging
  onCheckoutComplete={({ sessionId }) => {
    processLargePayment(sessionId)
  }}
>
  <button>Pay $1,000</button>
</TrailsWidget>
```

<Note>
CCTP is recommended for large payments as it transfers native USDC rather than wrapped/bridged variants.
</Note>

## USDT Examples

### Accept USDT on Ethereum

```tsx
<TrailsWidget
  apiKey="YOUR_API_KEY"
  mode="pay"
  toAddress="0xYOUR_MERCHANT_ADDRESS"
  toAmount="250"
  toChainId={1} // Ethereum
  toToken="USDT"
  onCheckoutComplete={({ sessionId }) => {
    confirmPayment(sessionId)
  }}
>
  <button>Pay $250 in USDT</button>
</TrailsWidget>
```

### Accept USDT on BNB Chain

```tsx
<TrailsWidget
  apiKey="YOUR_API_KEY"
  mode="pay"
  toAddress="0xYOUR_MERCHANT_ADDRESS"
  toAmount="75"
  toChainId={56} // BNB Chain
  toToken="USDT"
  onCheckoutComplete={({ sessionId }) => {
    confirmPayment(sessionId)
  }}
>
  <button>Pay $75 in USDT</button>
</TrailsWidget>
```

## Merchant Settlement Pattern

Complete checkout flow with backend verification:

```tsx
import { TrailsWidget } from '0xtrails/widget'
import { useState } from 'react'

export function StablecoinCheckout({ order, settlementChain = 8453 }) {
  const [status, setStatus] = useState<'idle' | 'processing' | 'complete' | 'failed'>('idle')

  return (
    <TrailsWidget
      apiKey={process.env.NEXT_PUBLIC_TRAILS_API_KEY}
      mode="pay"
      toAddress={process.env.NEXT_PUBLIC_MERCHANT_WALLET}
      toAmount={order.total.toString()}
      toChainId={settlementChain}
      toToken="USDC"
      onCheckoutStart={({ sessionId }) => {
        // Create pending payment record
        fetch('/api/payments', {
          method: 'POST',
          body: JSON.stringify({ orderId: order.id, sessionId, status: 'pending' })
        })
        setStatus('processing')
      }}
      onCheckoutComplete={async ({ sessionId }) => {
        // Verify on backend before fulfillment
        const res = await fetch(`/api/payments/${sessionId}/verify`, { method: 'POST' })
        const { verified } = await res.json()

        if (verified) {
          setStatus('complete')
          window.location.href = `/orders/${order.id}/confirmation`
        } else {
          setStatus('failed')
        }
      }}
      onCheckoutError={({ error }) => {
        console.error('Payment failed:', error)
        setStatus('failed')
      }}
    >
      <button disabled={status === 'processing'}>
        {status === 'processing' ? 'Processing...' : `Pay $${order.total}`}
      </button>
    </TrailsWidget>
  )
}
```

### Backend Verification

Always verify payments server-side before fulfilling orders:

```typescript
// app/api/payments/[sessionId]/verify/route.ts
import { Trails } from '@0xtrails/api'

const trails = new Trails({ accessKey: process.env.TRAILS_ACCESS_KEY })

export async function POST(req: Request, { params }: { params: { sessionId: string } }) {
  const { sessionId } = params

  const receipt = await trails.getIntentReceipt({ intentId: sessionId })

  if (receipt.status !== 'COMPLETED') {
    return Response.json({ verified: false, reason: 'Payment not completed' })
  }

  // Update your database
  await db.payments.update({
    where: { sessionId },
    data: { status: 'verified', completedAt: new Date() }
  })

  return Response.json({ verified: true, receipt })
}
```

## Multi-Currency Settlement

Accept multiple stablecoins and let users choose:

```tsx
const SETTLEMENT_OPTIONS = [
  { chain: 8453, token: 'USDC', label: 'USDC on Base' },
  { chain: 42161, token: 'USDC', label: 'USDC on Arbitrum' },
  { chain: 1, token: 'USDT', label: 'USDT on Ethereum' },
]

function MultiCurrencyCheckout({ order }) {
  const [settlement, setSettlement] = useState(SETTLEMENT_OPTIONS[0])

  return (
    <div>
      <select onChange={(e) => setSettlement(SETTLEMENT_OPTIONS[e.target.selectedIndex])}>
        {SETTLEMENT_OPTIONS.map((opt) => (
          <option key={`${opt.chain}-${opt.token}`}>{opt.label}</option>
        ))}
      </select>

      <TrailsWidget
        apiKey="YOUR_API_KEY"
        mode="pay"
        toAddress="0xYOUR_MERCHANT_ADDRESS"
        toAmount={order.total.toString()}
        toChainId={settlement.chain}
        toToken={settlement.token}
        onCheckoutComplete={({ sessionId }) => verifyPayment(sessionId)}
      >
        <button>Pay ${order.total}</button>
      </TrailsWidget>
    </div>
  )
}
```

## Supported Stablecoins by Chain

| Chain | Chain ID | USDC | USDT | DAI | CCTP Support |
|-------|----------|------|------|-----|--------------|
| Ethereum | 1 | ✓ | ✓ | ✓ | ✓ |
| Base | 8453 | ✓ | ✓ | ✓ | ✓ |
| Arbitrum | 42161 | ✓ | ✓ | ✓ | ✓ |
| Optimism | 10 | ✓ | ✓ | ✓ | ✓ |
| Polygon | 137 | ✓ | ✓ | ✓ | ✓ |
| Avalanche | 43114 | ✓ | ✓ | ✓ | ✓ |
| BNB Chain | 56 | ✓ | ✓ | ✓ | - |

<Note>
For the complete list of supported chains and tokens, see [Supported Chains](/resources/supported-chains).
</Note>

## Stablecoin Contract Addresses

Common stablecoin addresses for API integrations:

```typescript
const USDC_ADDRESSES = {
  1: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',      // Ethereum
  8453: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',   // Base
  42161: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831',  // Arbitrum
  10: '0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85',     // Optimism
  137: '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359',    // Polygon
}

const USDT_ADDRESSES = {
  1: '0xdAC17F958D2ee523a2206206994597C13D831ec7',      // Ethereum
  8453: '0xfde4C96c8593536E31F229EA8f37b2ADa2699bb2',   // Base
  42161: '0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9',  // Arbitrum
  56: '0x55d398326f99059fF775485246999027B3197955',     // BNB Chain
}
```

## API-Based Stablecoin Payments

For server-side integrations without the widget:

```typescript
const quote = await fetch('https://trails-api.sequence.app/rpc/Trails/QuoteIntent', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-Access-Key': process.env.TRAILS_ACCESS_KEY
  },
  body: JSON.stringify({
    ownerAddress: userWalletAddress,
    originChainId: 137,                    // User's funds on Polygon
    originTokenAddress: USDC_ADDRESSES[137],
    destinationChainId: 8453,              // Settle on Base
    destinationTokenAddress: USDC_ADDRESSES[8453],
    destinationToAddress: merchantAddress,
    destinationTokenAmount: '100000000',   // 100 USDC (6 decimals)
    tradeType: 'EXACT_OUTPUT'
  })
})

const { intent } = await quote.json()

// User signs and executes via CommitIntent + ExecuteIntent
```

## Best Practices

<AccordionGroup>
  <Accordion title="Choose the Right Settlement Chain">
    - **Base**: Lowest fees, fast finality, CCTP support
    - **Arbitrum**: Low fees, high liquidity, CCTP support
    - **Ethereum**: Highest liquidity, higher fees—best for large payments
    - **Polygon**: Low fees, good for high-volume small payments
  </Accordion>

  <Accordion title="Handle Price Volatility">
    - Quote validity is 5 minutes—don't cache quotes longer
    - For large payments, re-quote before final confirmation
    - Consider adding a small slippage buffer (0.5-1%) for volatile markets
  </Accordion>

  <Accordion title="Security Considerations">
    - Always verify payments on your backend before fulfillment
    - Store session IDs and map them to orders
    - Never trust client-side payment confirmations alone
    - Use environment variables for API keys, never expose in client code
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Pay Mode Reference" icon="code" href="/sdk/modes/pay">
    Complete SDK configuration options
  </Card>
  <Card title="Gasless Payments" icon="gas-pump" href="/examples/gasless">
    Let users pay gas fees in stablecoins
  </Card>
  <Card title="API Reference" icon="book" href="/api-reference/introduction">
    Server-side integration documentation
  </Card>
  <Card title="Supported Chains" icon="link" href="/resources/supported-chains">
    Full list of chains and tokens
  </Card>
</CardGroup>
