---
title: "Getting Started"
description: "Learn how to integrate the Trails API for cross-chain transactions"
---

## Welcome to the Trails API

The Trails API enables seamless cross-chain token swaps, deposits, payments, and smart contract executions in a simplified interface with the Trails protocol. This guide walks you through the complete flow from requesting a quote to executing a transaction.

## Core Workflow

Every interaction through Trails follows this four-step process:

```mermaid
flowchart LR
    A[Request Quote] --> B[Commit Quote]
    B --> C[Execute Quote]
    C --> D[Monitor Intent]
```

<Steps>
  <Step title="Get Wallet Balance">
    Before requesting a quote, fetch the user's token balances using an Indexer Gateway to display available tokens and amounts:

```typescript
const balancesResponse = await fetch('https://indexer.sequence.app/rpc/IndexerGateway/GetTokenBalances', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-Access-Key': 'AQAAAAAAAF_JvPALhBthL7VGn6jV0YDqaFY'
  },
  body: JSON.stringify({
    accountAddress: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb',
    includeMetadata: true
  })
});

const { balances } = await balancesResponse.json();

// Display balances in your UI for user to select token and amount
console.log('Available tokens:', balances);
```
  </Step>

  <Step title="Get a Quote">
    Request a quote to see rates, fees, and routing options for your transaction.

```typescript
const quoteResponse = await fetch('https://trails-api.sequence.app/rpc/Trails/QuoteIntent', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    ownerAddress: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb', // sender address
    originChainId: 42161, // Arbitrum One
    originTokenAddress: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831', // USDC
    originTokenAmount: 100000000, // 100 USDC (6 decimals)
    destinationChainId: 8453, // Base
    destinationTokenAddress: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base
    destinationToAddress: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb', // recipient
    tradeType: 'EXACT_INPUT',
    options: {
      slippageTolerance: 0.5, // 0.5%
      quoteProvider: 'RELAY'
    }
  })
});

const { intent, gasFeeOptions } = await quoteResponse.json();

console.log('Quote received:', {
  fromAmount: intent.quote.fromAmount,
  toAmount: intent.quote.toAmount,
  totalFees: intent.fees.totalFeeUsd,
  expiresAt: intent.expiresAt
});
```

**Key Parameters:**

- **ownerAddress**: User's sender address
- **originChainId** & **destinationChainId**: Source and destination chains
- **originTokenAddress** & **destinationTokenAddress**: Token contracts
- **originTokenAmount**: Amount to swap (in token's smallest unit)
- **tradeType**: `EXACT_INPUT` (specify input) or `EXACT_OUTPUT` (specify output)

<Tip>
Use `EXACT_INPUT` when you know how much you want to spend, and `EXACT_OUTPUT` when you know exactly how much you need to receive.
</Tip>
  </Step>

  <Step title="Commit the Intent">
    Lock in the quote by committing the intent from the previous response which will reserve the rates.

```typescript
const commitResponse = await fetch('https://trails-api.sequence.app/rpc/Trails/CommitIntent', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({ intent })
});

const { intentId } = await commitResponse.json();

console.log('Intent committed:', intentId);
```

<Warning>
Committed intents expire after a set period (check `intent.expiresAt`). Execute before expiration or request a new quote.
</Warning>
  </Step>

  <Step title="Execute the Transaction">
    Now we can execute the intent. There are two ways to do this: the traditional flow (send tokens onchain) or the gasless flow to enable users to pay gas with non-native tokens:

<Tabs>
  <Tab title="Transfer Flow">
    Send tokens to the intent address, then call ExecuteIntent with the transaction hash:

```typescript
// First, send tokens to the intent address
const depositTx = await walletClient.sendTransaction({
  to: intent.depositTransaction.toAddress,
  value: 0n,
  data: encodeERC20Transfer( // Use your favorite library such as viem to encode if ERC20 transfer
    intent.depositTransaction.tokenAddress,
    intent.depositTransaction.toAddress,
    intent.depositTransaction.amount
  )
});

// Wait for transaction confirmation using viem
const receipt = await publicClient.waitForTransactionReceipt({
  hash: depositTx
});

// Then execute the intent with the deposit transaction hash and intentId
const executeResponse = await fetch('https://trails-api.sequence.app/rpc/Trails/ExecuteIntent', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    intentId,
    depositTransactionHash: depositTx
  })
});

const { intentStatus } = await executeResponse.json();
console.log('Execution started:', intentStatus);
```
  </Tab>

  <Tab title="Alternative Fee Token Flow">
    Sign ERC712 permit signatures which enables paying with any non-native gas tokens that are permit compatible:

```typescript
// Select a gas fee option from the quote response
const selectedGasFeeOption = gasFeeOptions[0]; // Choose based on user preference

// 1. Sign the intent signature (ERC712) with fee payment authorization
const intentSignature = await walletClient.signTypedData({
  domain: {
    name: 'Trails',
    version: '1',
    chainId: intent.originChainId,
    verifyingContract: intent.depositTransaction.toAddress // intent address
  },
  types: {
    Intent: [
      { name: 'user', type: 'address' },
      { name: 'token', type: 'address' },
      { name: 'amount', type: 'uint256' },
      { name: 'intentAddress', type: 'address' },
      { name: 'deadline', type: 'uint256' },
      { name: 'chainId', type: 'uint256' },
      { name: 'nonce', type: 'uint256' },
      { name: 'feeAmount', type: 'uint256' },
      { name: 'feeCollector', type: 'address' }
    ]
  },
  primaryType: 'Intent',
  message: {
    user: intent.ownerAddress,
    token: intent.depositTransaction.tokenAddress,
    amount: intent.depositTransaction.amount,
    intentAddress: intent.depositTransaction.toAddress,
    deadline: intent.deadline,
    chainId: intent.originChainId,
    nonce: intent.userNonce,
    feeAmount: selectedGasFeeOption.feeAmount,
    feeCollector: selectedGasFeeOption.feeCollector
  }
});

// 2. Sign the ERC20 permit (ERC2612) for token approval
const permitDeadline = Math.floor(Date.now() / 1000) + 3600; // 1 hour from now
const permitAmount = intent.depositTransaction.amount;

const permitSignature = await walletClient.signTypedData({
  domain: {
    name: 'USD Coin', // Get from token contract
    version: '1',
    chainId: intent.originChainId,
    verifyingContract: intent.depositTransaction.tokenAddress
  },
  types: {
    Permit: [
      { name: 'owner', type: 'address' },
      { name: 'spender', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'nonce', type: 'uint256' },
      { name: 'deadline', type: 'uint256' }
    ]
  },
  primaryType: 'Permit',
  message: {
    owner: intent.ownerAddress,
    spender: intent.depositTransaction.toAddress,
    value: permitAmount,
    nonce: 0, // Get current nonce from token contract's nonces(address) function
    deadline: permitDeadline
  }
});

// 3. Execute with signatures instead of transaction hash
const executeResponse = await fetch('https://trails-api.sequence.app/rpc/Trails/ExecuteIntent', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    intentId,
    depositSignature: {
      intentSignature,
      permitSignature,
      permitDeadline,
      permitAmount,
      selectedGasFeeOption,
      userNonce: intent.userNonce,
      deadline: intent.deadline
    }
  })
});

const { intentStatus } = await executeResponse.json();
console.log('Execution started:', intentStatus);
```

<Note>
The gasless flow requires ERC2612-compatible tokens (tokens with `permit()` function). The intent signature includes fee payment details, allowing users to pay gas fees with the transfer token.
</Note>
  </Tab>
</Tabs>
  </Step>

  <Step title="Monitor Completion">
    Wait for the transaction to complete using the streaming endpoint:

```typescript
async function waitForCompletion(intentId: string) {
  while (true) {
    const waitResponse = await fetch(
      'https://trails-api.sequence.app/rpc/Trails/WaitIntentReceipt',
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ intentId })
      }
    );

    const { intentReceipt, done } = await waitResponse.json();

    console.log('Status:', intentReceipt.status);

    // If done is true, the intent has reached a terminal state
    if (done) {
      if (intentReceipt.status === 'SUCCEEDED') {
        console.log('âœ… Transaction completed!');
        console.log('Deposit TX:', intentReceipt.depositTransaction.txnHash);
        console.log('Origin TX:', intentReceipt.originTransaction.txnHash);
        console.log('Destination TX:', intentReceipt.destinationTransaction.txnHash);
        return intentReceipt;
      } else {
        throw new Error('Transaction failed: ' + intentReceipt.originTransaction.statusReason);
      }
    }
    
    // If not done, the endpoint will have waited internally before returning until completion
  }
}

const receipt = await waitForCompletion(intentId);
```
  </Step>
</Steps>

## Support

Need help? Join our community:

- **Telegram**: [https://t.me/build_with_trails](https://t.me/build_with_trails)
- **Documentation**: Browse the endpoint references for detailed information and advanced use cases
- **Demo**: Try the [interactive playground](https://demo.trails.build/widget)
