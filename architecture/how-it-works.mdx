---
title: 'How Trails Works'
description: 'Core architecture and design of the Trails transaction rails protocol'
icon: 'sitemap'
---

Trails offers developers a solution to enable 1-click crypto experiences via any wallet, token and chain. Trails aims to make EVM chains "work as one" by solving the widespread chain, token, and wallet fragmentation problems by providing a multichain transaction orchestration layer on top of wallets powered by intents that unifies all chains and automates token routing, all with a single end-user confirmation (1-click).

## Overview

Trails automatically determines the optimal path for cross-chain transaction execution, whether it's a simple single-chain transaction or a complex multi-step orchestration involving swaps, bridges, and executions across different blockchains.

Trails is built on the [Sequence](https://docs.sequence.xyz) wallet stack combining the powers of account abstraction, real-time indexing, and gasless transaction execution into an intent-powered chain abstraction solution. Trails is designed to work with any wallet, including a simple EOA wallet, a powerful smart wallet or an in-app embedded wallet (ie. MetaMask, Wallet Connect, Privy, Coinbase Smart Wallet, etc). For more details under-the-hood, please see the [protocol architecture](/architecture/protocol) section.

The protocol is designed to be extensible, with plans to support non-EVM chains in the future.

## Step-by-Step Flow

<Steps>
  <Step title="User Initiates Payment">
    **Trigger any action requiring payment**
    
    The user clicks "Buy", "Mint", "Deposit", or initiates any action requiring payment on a dapp, triggering the Trails flow. The action can be priced in any token on any chain, and users can select any desired token from any chain from their balance to execute the payment.

  </Step>

  <Step title="Intent Address Generation">
    **Compute a unique intent contract address**
    
    A unique intent contract address is computed based on the full transaction orchestration across multiple chains. The intent address encodes the details of transactions on both the origin and destination chains enabling onchain cryptographic execution.

    <Note>
      The user's wallet is the only party with control over this intent address.
    </Note>
  </Step>

  <Step title="Origin Transfer">
    **Single user confirmation to deposit tokens**
    
    The user sends a single transaction to deposit their tokens (from any chain they hold funds on) into the intent address on the origin chain. This is the **only transaction the user needs to sign**.

    <Tip>
      Any bridges, swaps, and execution logic necessary to complete the payment are handled automatically from this point forward.
    </Tip>
  </Step>

  <Step title="Origin Chain Execution">
    **Relayer executes the encoded origin transaction**
    
    The Relayer automatically executes an operation on the origin intent address by submitting a merkle proof to execute the encoded origin transaction:

    - **Trustless Execution**: The Relayer is unable to modify the transaction contents
    - **Permissionless**: Any party can safely trigger the intent transaction to move it forward
    - **Automated**: Handles any required swaps or bridge operations on the origin chain

  </Step>

  <Step title="Destination Chain Arrival">
    **Bridged funds arrive at the destination intent address**
    
    The bridged funds arrive at the corresponding intent address on the destination chain, ready for the final execution.

  </Step>

  <Step title="Final Settlement">
    **Complete the payment on the destination chain**
    
    The Relayer executes the final wallet operation on the destination intent address by submitting a merkle proof to execute the encoded destination transaction:

    - **Send funds to the recipient**
    - **Execute any required contract calls**
    - **Perform other specified actions (mint, deposit, etc.)**

    <Info>
      This intent-based approach ensures users only sign **one transaction** while the system handles all the complex routing, bridging, execution, and settlement logic automatically across multiple chains.
    </Info>
  </Step>
</Steps>


## Key Benefits

<CardGroup cols={2}>
  <Card title="Simplified UX" icon="hand-sparkles">
    Users interact with a simple interface while Trails handles complex cross-chain orchestration
  </Card>
  <Card title="Optimal Routing" icon="route">
    Intelligent algorithms find the most efficient paths across chains and protocols
  </Card>
  <Card title="Cost Effective" icon="dollar-sign">
    Minimizes fees and gas costs through smart routing and batching
  </Card>
  <Card title="Secure" icon="shield-check">
    Non-custodial architecture ensures users maintain control of their assets
  </Card>
</CardGroup>


## Technical Architecture

The Trails protocol leverages several key components:

- **Intent Recognition**: Parses and understands user payment intentions
- **Route Optimization**: Calculates optimal paths across supported chains
- **Protocol Integration**: Interfaces with DEXs, bridges, and other protocols
- **Transaction Orchestration**: Coordinates complex multi-step operations
- **Execution Engine**: Handles the actual transaction execution and monitoring


## Integration with External Protocols & Liquidity Networks

Trails is a composable solution which is able to plug-in to virtually any existing cross or same-chain infrastructure to efficiently route transactions.

- **Trails as an Orchestrator**: Trails does not custody funds or act as a bridge/DEX itself. It orchestrates flows across existing liquidity networks and chains, acting as the glue that connects them so they work seamlessly as one.
- **Liquidity Providers (LPs) & DEXs**: Trails taps into AMMs, bridges, aggregators, and LPs to source liquidity and pricing, selecting the optimal venue per step of the route, providing the best price and gas efficiency possible for the end-user.
- **Pluggable Architecture**: New protocols, bridges, and networks can be added without changing code. Trails evaluates options at runtime and selects the safest, most efficient path, giving the developer full control over the flow.

<Note>
  Trails is responsible for orchestrating the flow, not holding user assets. It coordinates protocols so users can transact with a single click (one transaction on the original chain), while assets move through underlying networks.
 </Note>

## Refunds

Trails has an automatic refund mechanism built in to protect your assets in the event of a transaction failure.

| Failure Scenario | Refund Action |
|------------------|---------------|
| **Failure on the Source Chain** | If the transaction fails before your funds leave the initial blockchain, the user will receive a full refund (minus gas fees) on the source chain to the sender address. |
| **Failure on the Destination Chain** | If the funds successfully bridged but the final step fails on the destination chain, the assets are refunded to your sender address on the destination chain. |

## Security & Validation

- **Built on Sequence v3**: Trails is built on top of Sequence's audited v3 wallet contracts, leveraging mature account abstraction and battle-tested controls.
- **Intent-Scoped Authorization**: Intent addresses are only used to trustlessly authorize the specific transaction calldata the user has explicitly permitted—nothing more.
- **User “sudo” Control**: The user always retains control over their account and funds. In emergencies, they can take direct action at any time.
- **Non-Custodial by Design**: Trails never takes custody; execution happens via the user's wallet permissions, preserving full control and auditability.
